[{"title":"vuex 学习笔记","url":"/articles/10010/","content":"### Vuex learning\n[vuex文档](https://vuex.vuejs.org/zh/)\n\n####  Vuex 是什么？\n+ Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**，采用集中式存储管理应用的所有组件的状态\n\n#### 使用场景\n+ 应用够简单，最好不要使用 Vuex\n+ 构建中大型单页应用——考虑如何更好地在组件外部管理状态——Vuex \n+ **安装：`npm install vuex -S`**\n+ **引入：`import Vuex from 'vuex'` 、`Vue.use(Vuex)`** \n\n#### 核心\n+ **store（仓库）：**包含着你的应用中大部分的**状态 (state)**\n>\t1.  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，\t\t若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n> 2.  不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。\n\t\n+ **state：**存储在store中的，与data中定义的属性相似，只不过它是共享的\nVuex 使用**单一状态树**，每个应用仅仅包含一个 store 实例\n\t\n**1）在 Vue 组件中获得 Vuex 状态：**\n\t\n+ 在计算属性中返回：（需要导入store，每次使用都需要导入）\n\n\n```js\ncomputed: {\n\tcount () {\n\t\treturn store.state.count\n\t}\n}\n```\n+ 在根实例中注册 `store` 选项\n\n\n```js\nnew  Vue({\n\tel:  '#app',\n\trouter,\n\tstore,\n\tcomponents: { App },\n\ttemplate:  '<App/>'\n})\n```\nstore 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到\n\n\n```js\ncomputed:{\n\tcounter(){\n\t\treturn  this.$store.state.count\n\t}\n},\n```\n! 好处：只用注册一次，不再需要频繁导入\n\n**2）`mapState`  辅助函数**\n当一个组件需要获取多个状态时候，帮助生成计算属性，而不需要一个一个去定义计算属性\n结合对象展开运算符使用可以简写如下：\n```js\n...mapState([\n\t'verifyStatus',\n\t'verifyReturn',\n\t'checkPswdResult',\n\t'codeInfo',\n\t'chnageInfo',\n]),\n```\n如此便定义了多个计算属性，不用一个个声明\n\n！使用 Vuex 并不意味着将**所有的**状态放入 Vuex。应该根据应用开发需要进行权衡和确定。\n\n+ **Getters：**\nVuex 允许在 store 中定义“getter”（可以认为是 store 的计算属性）。\n就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n+ `getters` 方法接受的参数可以是：`state`、其他`getters`\n+ 注册的 getter 暴露为 `store.getters`\n\n+ **Mutation**\n**1）更改 Vuex 的 store 中的状态的唯一方法是提交 mutation**\n**更改 Vuex 的 store 中的状态的唯一方法是提交 mutation**\n**更改 Vuex 的 store 中的状态的唯一方法是提交 mutation**\n\n> mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**\n\n**不能直接调用一个 mutation handler**\n需要以相应的 type 调用 **store.commit** 方法\n\n\n```js\nmutations: {\n\tincrement (state) {\n\t\tstate.count++\n\t}\n}\n\nstore.commit('increment')\n```\n2）可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**，大多数情况下，载荷是一个对象，\n```js\nmutations: {\n\tincrement (state, payload) {\n\tstate.count += payload.amount\n\t}\n}\n\nstore.commit('increment',{\n\tamount:10\n})\n```\n提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：\n```js\nstore.commit({\n\ttype: 'increment',\n\tamount: 10\n})\n```\n**3）Mutation 必须是同步函数**\n4）可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation\n或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用\n\n+ **Action**\n**1）基本使用形式**\n> Action 类似于 mutation，不同在于：\n-   Action 提交的是 mutation，而不是直接变更状态。\n-   Action 可以包含任意异步操作。\n\n\n```js\nactions: {\n\tincrement (context) {\n\t\tcontext.commit('increment')\n\t}\n}\n```\n>Action 函数接受了一个与 store 实例具有相同方法和属性的 context 对象，所以可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。\n\n一般使用时会用参数解构来简化代码，写成下面的形式：\n```js\nactions: {\n\tincrement ({ commit }) {\n\t\tcommit('increment')\n\t}\n}\n```\n2）分发 Action\nAction 通过 `store.dispatch` 方法触发\n**Action 就不受同步约束！可以在 action 内部执行异步操作**\n```js\nactions: {\n\tchangePassword({commit},{old,newpass}){\n\t\tdoChangePassword(newpass,old,(data) => {\n\t\t\tcommit('password', data)\n\t\t}).then(res  => {\n\t\t\tcommit('password',res)\n\t\t})\n\t},\n}\n```\nActions 支持同样的载荷方式和对象方式进行分发\n在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用。\n\n+ **Module**\n可以将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块\n\n+ 对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。\n+ 对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`\n\n\n```js\nactions: {\n\tincrementIfOddOnRootSum ({ state, commit, rootState }) {\n\t\tif ((state.count + rootState.count) % 2 === 1) {\n\t\t\tcommit('increment')\n\t\t}\n\t}\n}\n```\n+ 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\n\n```js\ngetters: {\n\tsumWithRootCount (state, getters, rootState) {\n\t\t\treturn state.count + rootState.count\n\t}\n}\n```\n+ **命名空间**：若希望模块具有更高的封装度和复用性，可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块\n+ 在带命名空间的模块注册全局 action：添加 `root: true`，并将这个 action 的定义放在函数 `handler` 中\n+ 模块动态注册：`store.registerModule`，之后就可以通过 `store.state.myModule` 和 `store.state.nested.myModule` 访问模块的状态\n\n+ **项目结构**\n>Vuex 并不限制代码结构。但是，它规定了一些需要遵守的规则：\n>1.  应用层级的状态应该集中到单个 store 对象中。\n>2.  提交  **mutation**  是更改状态的唯一方法，并且这个过程是同步的。\n>3.  异步逻辑都应该封装到  **action**  里面。\n\n\t\n+ **记我的项目使用vuex顺序：**\n+ 先写`service`，在`model`中引入`service`，在`action`中处理异步，把改动commit，把然后在`mutation`中处理state的变化\n+ 在组件中引入`mapState`和 `mapAction `，然后把`state`写在`computed`中，把`action`写在`methods`中，`state`就可以直接使用，`action`在需要的地方调用就可以。\n\t\n","tags":["kilimanjaro"]},{"title":"vue-router 学习笔记","url":"/articles/10009/","content":"### Vue Router 查漏补缺\n[文档](https://router.vuejs.org/zh/installation.html)\n#### 一、 动态路由匹配\n！当使用路由参数时，例如从 `/user/foo` 导航到 `/user/bar`，**原来的组件实例会被复用**——这意味着组件的生命周期钩子不会再被调用，\nSo：想对路由参数的变化作出响应的话，可以 \n1）watch `$route` 对象\n2）使用`beforeRouteUpdate`  [导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)\n\n+ 匹配优先级：同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序——**谁先定义的，谁的优先级就最高**\n#### 二、 嵌套路由：\n\n1）`<router-view>`渲染最高级路由匹配到的组件，不要是个组件都加\n2）提供一个空的子路由，会被渲染出来\n```js\nroutes: [\n    {\n      path: '/user/:id', component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 <router-view> 中\n        { path: '', component: UserHome },\n\n        // ...其他子路由\n      ]\n    }\n  ]\n```\n\n#### 三、 声明式导航VS编程式导航\n1）声明式：`<router-link :to=\"...\">` `<router-link :to=\"...\" replace>`\n2）编程式：`router.push(...)` `router.replace(...)` `router.go(n)`\n+  `router.replace(...)` VS`router.push` ：唯一的不同就是，前者不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录\n+  `router.go(n)`接受一个整数，在 history 记录中向前或者后退多少步\n\n\n`router.push`方法的参数可以是一个字符串路径，或者一个描述地址的对象\n>**如果提供了  `path`，`params`  会被忽略:**\n```js\nconst userId = 123\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n> 同样的规则也适用于 `router-link` 组件的 `to` 属性\n\n\t\t\n**！应习惯使用声明式，省了写点击事件和处理逻辑**\n\n#### 四、重定向\n重定向”的意思是，当用户访问 `/a`时，URL 将会被替换成 `/b`\n```js\n  routes: [\n    { path: '/a', redirect: '/b' }\n  ]\n```\n\n#### 五、导航守卫\n导航守卫主要用来通过跳转或取消的方式来守卫导航\n记住**参数或查询的改变并不会触发进入/离开的导航守卫**：可以通过[观察  `$route`  对象](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96)来应对这些变化，或使用 `beforeRouteUpdate` 的组件内守卫。\n\n+ **1）全局守卫**\n```js\nrouter.beforeEach((to, from, next) => {\n  // ...\n})\n```\n-   **`next: Function`**: 一定要调用该方法来  **resolve**  这个钩子。执行效果依赖  `next`  方法的调用参数。\n    \n    -   **`next()`**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是  **confirmed**  (确认的)。  \n    -   **`next(false)`**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到  `from`  路由对应的地址。 \n    -   **`next('/')`  或者  `next({ path: '/' })`**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向  `next`  传递任意位置对象。 \n    -   **`next(error)`**: (2.4.0+) 如果传入  `next`  的参数是一个  `Error`  实例，则导航会被终止且该错误会被传递给  [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror)  注册过的回调。\n        **确保要调用  `next`  方法，否则钩子就不会被 resolved。**\n\n+ 没有使用next方法，输出to 和 from的信息，但是路由不会跳转\n\t```js\n\tRouter.beforeEach((to,from,next)=>{\n\t\tconsole.log(to)\n\t\tconsole.log(from)\n\t})\n\t```\n+ 使用next()，正常跳转\n\t```js\n\tRouter.beforeEach((to,from,next)=>{\n\t\tnext()\n\t})\n\t```\n+ next(false)，不会跳转\n\t```js\n\tRouter.beforeEach((to,from,next)=>{\n\t\tnext(false)\n\t})\n\t```\n+ next('/intro')，\n\t```js\n\tRouter.beforeEach((to,from,next)=>{\n\t\tnext('/')\n\t})\n\t```\n\t仅仅这么写会报错：`vue-router.esm.js?fe87:1905 RangeError: Maximum call stack size exceeded` `[vue-router] uncaught error during route navigation:`\n\n\t原因：next()直接跳转到to.path路径，没有再执行一遍beforeEach导航钩子，而next('/')这一种自己指定路径的，路由跳转的时候还执行一遍beforeEach导航钩子，所以出现死循环，会一直输出造成栈溢出\n\t解决：先利用`to.path`判断一下将要去的路由，分别处理如：\n\t```js\n\tRouter.beforeEach((to,from,next)=>{\n\t\tif(to.path  ==  '/'){\n\t\t\tnext()\n\t\t}\n\t\telse{\n\t\t\tnext('/')\n\t\t}\n\t})\n\t```\n\t这样就能实现正确的跳转\n\t**next('/')这种跳转可以用于处理登录跳转逻辑**\n\t\n+ **2）全局解析守卫**\n\n\t可以用 `router.beforeResolve` 注册一个全局守卫，和 `router.beforeEach` 类似\n**区别：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用**\n\n+ **3）路由独享的守卫**\n可以在路由配置上直接定义 `beforeEnter` 守卫，与全局前置守卫的方法参数一样\n\t```js\n\t{\n\t\tpath:  '/intro',\n\t\tname:  'Information',\n\t\tcomponent:  Information,\n\t\tbeforeEnter:(to,from,next)=>{\n\t\t\tconsole.log(to)\n\t\t\tconsole.log(from)\n\t\t\tnext()\n\t\t}\n\t},\n\t```\n+ **4）全局后置钩子**\n\t+  这些钩子不会接受 `next` 函数也不会改变导航本身：`router.afterEach((to, from) => { // ... })`\n\n+ **5）组件内的守卫**\n\t-   `beforeRouteEnter`\n\t\t+  **`beforeRouteEnter` 守卫 **不能** 访问 `this`**，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。但可以通过传一个回调给 `next`来访问组件实例，**`beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫**\n在组件的与methods和data等平行的地方使用：\n\t```js\n\tbeforeRouteEnter (to, from, next) {\n\t\tnext(vm  => {\n\t\t\tconsole.log(vm.dialogVisible)\n\t\t})\n\t}\n\t```\n\t-   `beforeRouteUpdate`  \n\t\t+ 可以访问`this`，**不支持**传递回调，因为没有必要\n\t-   `beforeRouteLeave`：通常用来禁止用户在还未保存修改前突然离开\n\t\t+ 可以访问`this`，**不支持**传递回调，因为没有必要\n\n+ **6） 完整的导航解析流程**[文档](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B)\n\n#### 六、过渡动效\n+ `<router-view>` 是基本的动态组件，所以我们可以用 `<transition>` 组件给它添加一些过渡效果\n#### 七、数据获取\n+ 1）导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示\n+ 2）导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。\n\n#### 八、 滚动行为\n+ vue-router可以自定义路由切换时页面如何滚动\n+ 这个功能只在支持  `history.pushState`  的浏览器中可用\n\t ```js\n\tscrollBehavior (to, from, savedPosition) {\n\t   return { x: 0, y: 0 }\n\t}\n\t```\n\n#### 九、路由懒加载\n```js\n{\n\tpath:  '/account/password',\n\tname:  'Password',\n\tcomponent: () =>\n\t\timport (/* webpackChunkName: \"password\" */  '../components/password'),\n},\n```\n按照这种形式把某个路由下的所有组件都打包在同个异步块 (chunk) 中，便可以实现加载到相应模块时才加载相应的js\n最后可以看到build出来的效果：\n```\n                              Asset     Size         Chunks               Chunk Names\nstatic/js/1.30d7fd584322d8118003.js    8.07 kB       1  [emitted]         home\nstatic/js/2.2e83b87ec6e4631f040a.js    40.6 kB       2  [emitted]         intro\nstatic/js/3.3a4088c85a093777b888.js    3.87 kB       3  [emitted]         password                    \nstatic/js/4.62db8a2584adfea19a93.js  884 bytes       4  [emitted]         account\nstatic/js/5.103e7ab1dd6ce83e32b9.js    1.73 kB       5  [emitted]         manage\n```","tags":["kilimanjaro"]},{"title":"图标字体","url":"/articles/10008/","content":"### 图标字体制作（@font-face）\n####  一、CSS3 @font-face\n1）浏览器支持\n+  Internet Explorer 9 只支持 .eot 类型的字体, Firefox, Chrome, Safari, 和 Opera 支持 .ttf 与.otf 两种类型字体.\n+ Internet Explorer 8 及更早IE版本不支持@font-face 规则.\n\n2） 使用意义\n+ 网站可以使用字体以外的预先选择“合法”字体\n\n3）使用语法\n+ 定义\n```css\n@font-face\n{\n\tfont-family: myFirstFont;\n\tsrc: url('Sansation_Light.ttf')\n\t\t,url('Sansation_Light.eot'); /* IE9 */\n\t\n\t/*\n\t 其余可选参数：\n\t font-stretch（如何拉伸）、\n\t font-style（字体样式）、\n\t font-weight（粗细）、\n\t unicode-range（字体支持Unicode字符的范围）\n\t*/\n\t\t\n}\n```\n+ 使用 \n```css\ndiv\n{\n\tfont-family:myFirstFont;\n}\n```\n! font-family命名若是原本系统就有的字体名称，会造成覆盖\n\n#### 二、利用`@font-face`制作像字体一样使用的icon\n+ [需要用到的网站](https://icomoon.io/)\n\t1）打开网站点击右上角`IcoMoon App`\n\t2）点击左上角`Import Icons`导入自己的`svg`图标， 或者选择下面已经有的图标\n\t3）点击选择一个或者多个图标后选择右下角`Generate Font`\n\t4）可以设置每个图标的名字或者使用默认的名字，(此时点击图标处的`Get Code`可以看到相应的代码）\n\t6）点击右下角`Download`即可下载压缩包\n\t5）解压后把文件中的`fonts`一整个文件夹导入项目中\n\t6）在项目中使用，代码如下：\n\t```css\n\t@font-face {\n\t\tfont-family: 'heart';\n\t\tsrc:  url('./assets/fonts/icomoon.eot') format('eot'),\n\t\t\t  url('./assets/fonts/icomoon.ttf') format('truetype'),\n\t\t\t  url('./assets/fonts/icomoon.woff') format('woff'),\n\t\t\t  url('./assets/fonts/icomoon.svg') format('svg');\n\t\tfont-style: normal;\n\t\tfont-weight: normal;\n\t}\n\t.icon {\n\t\tfont-family: 'heart';\n\t}\n\t```\n\t使用的时候需要带上相应的类名（icon-设置的图标名或者默认的图标名）\n\t代码可以在网站的每个图标点击`Get Code`即可看见\n\t```html\n\t<span  class=\"icon icon-icon-heart\"></span>\n\t```\n\t```css\n\t.icon-icon-heart:before {\n\t\tcontent: \"\\66\";\n\t\tcolor: #eb4f4f;\n\t}\n\t```\n\t到此为止便完成了svg图标字体的制作，此时引入的图标可以像使用字体一样，可以通过修改`font-size`改变大小，通过`color`改变颜色等\n\t```css\n\t.icon-icon-heart:before {\n\t\tcontent: \"\\66\";\n\t\tcolor: #e9eb4f;\n\t\tfont-size: 30px;\n\t}\n\t```\n\t\n\t","tags":["kilimanjaro"]},{"title":"Cropper js 进行头像裁剪","url":"/articles/10007/","content":"Cropper js 的使用\n[cropper js](https://github.com/fengyuanchen/cropperjs)\n\n+ 安装 `npm install cropperjs -S`\n+ 引入`import  Cropper  from  'cropperjs'`\n（在线引入：[地址](https://cdnjs.com/libraries/cropperjs)）\n+ 使用：\n`new Cropper(element[, options])`\n实例化：\n\t```js\n\tvar  img = document.getElementById(\"image\");\n\tvar  Cropper = new  window.Cropper(img,{\n\t\taspectRatio:  1, \n\t\tpreview:  document.getElementById(\"result\"),\n\t})\n\t```\n\t\n功能及其他参数看文档使用就好\n如旋转：\n`rotate(deg){ this.Cropper.rotate(deg) },`\n\n[中文文档参考](https://blog.csdn.net/weixin_38023551/article/details/78792400)\n\n+ 遇到的问题：\n\t预期的裁剪效果并没有出来，只有缩放功能，而且出现了两张图片，审查发现样式严重偏差\n\n\t解决：因为在组件中的样式用了`<style  scoped>`，所以引入的cropper js 的样式完全没有起作用，因此才会出现问题。\n\n\t`scoped`实现组件样式私有化：\n\t> -   给`HTML`的`DOM`节点加一个不重复`data`属性(形如：data-v-2311c06a)来表示他的唯一性\n\t> -   在每句`css`选择器的末尾（编译后的生成的css语句）加一个当前组件的`data`属性选择器（如[data-v-2311c06a]）来私有化样式\n\n\t所以因为我在组件中使用了`scoped`属性，让组件的样式私有化了，外部引入的cropper js 的样式没有起效果，让插件没有正常使用。\n\n\t**！对公共的样式进行抽取尽量写在外层，比如像App.vue中,其他的组件要被引用的也不使用scoped,让类名保持唯一来定义样式**\n\n+ 关于上传图片\n原理：利用`input`标签的`type=\"file\"`可以调取本地文件，`accept`可以限定上传文件的类型\n\t```html\n\t<input  type=\"file\"  id=\"file\"  class=\"file\"  accept=\"image/jpeg,image/png\"  @change=\"getImgFile\">\n\t```\n\t`FileReader`:\n\t文件读取方法`readAsDataURL`，可以将图片文件转换为`base64`编码,实现图片的预览\n\t```js\n\tlet  render  =  new  FileReader()\n\trender.readAsDataURL(this.file)\n\trender.onload  = (e) => {\n\t\tthis.img  =  e.target.result  //此处this.img是一个<img>的src的值\n\t}\n\t```\n\n    ```js\n        let myFunc = (someone) => {\n            console.log(`Happy birthday to ${someone} `)\n        }\n        myFunc('kilimanjaro')\n    ```\n\n\t\n\n","tags":["kilimanjaro"]},{"title":"跨域初探","url":"/articles/10006/","content":"### 跨域探索\n\n#### 一、 跨域是什么？\nA: 浏览器从一个域名的网页去请求另一个域名的资源时，**域名、端口、协议**任一不同，都是跨域\n\n+ localhost和127.0.0.1虽然都指向本机，但也属于跨域\n####  二、解决跨域的办法有什么？\n####  1、JSONP\nQ: what it is?\nA: `Jsonp(JSON with Padding)` : json 的一种\"使用模式\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据\n\nQ：原理是什么？\nA：`ajax`请求受同源策略影响——不允许进行跨域请求——而`script`标签`src`属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回`json`格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。\n`<link>`、` <img/>`等具有src属性的也有相同作用\n\nQ：如何操作？\nA：基本操作：\n```js\n<script>\n  function  test(res){\n    console.log(res)\n  }\n</script>\n<script src=\"https://suggest.taobao.com/sug?code=utf-8&q=%E9%9E%8B&_ksTS=1540456908748_511&callback=test&area=b2c&code=utf-8&k=1&bucketid=18&src=tmall_pc\">\n</script>\n```\n过程：随便在网上找到response形式为`jQuery110206760241575266825_1540457227891({\"q\":\"h\",\"p\":false,\"bs\":\"淘宝\",\"csor\":\"1\",\"status\":0,...});`的，拿到其请求的URL，把原地址中的cb或者callback参数的值改成自定义的函数名，如：`callback=test`，就可以看到请求拿到的结果，与原网页内容一致\n\n[其他学习   jsonp原理详解](https://blog.csdn.net/hansexploration/article/details/80314948)\n\nQ：如何在Vue中使用Jsonp实现请求？\nA：\n+ 安装：`npm install jsonp -S`\n+ 引入：`import  jsonp  from  'jsonp'`\n+ 使用：\n\t```js\n\t jsonp('https://suggest.taobao.com/sug?code=utf-8&q=%E9%9E%8B&_ksTS=1540456908748_511&area=b2c&code=utf-8&k=1&bucketid=18&src=tmall_pc', null, (err, data) => {\n      if (err) {\n\t    console.error(err.message);\n\t  } else {\n\t    console.log(data);\n      }\n   });\n   ```\n\t`jsonp(url,opts,fn(err,data))`\n\t>jsonp(url, opts, fn)   [引用参考](https://segmentfault.com/a/1190000012096966)\nurl (String) 服务器端数据接口地址  \nopts (Object) 一般只需关注param即可\n\t-   param (String) 默认是callback,这是与后端约定的参数名称，也可以随便定义，只要前后端统一\n\t-   timeout (Number) 请求超时时间，默认是6000ms   \n\t-   prefix (String) callback值的前缀，默认是__jp\n\t-   name (String) 指定全局注册的回调方法名，一般不会用到，因为默认是prefix+自增数字\nfn 回调方法\n\n\t**Jsonp只支持get请求，不支持post请求**\n\t\n#### 以下几种暂时了解了原理，尚待实践\n#### 2、CORS 跨域资源共享（Cross-origin resource sharing）\n[学习参考](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n+ 它允许浏览器向跨源服务器，发出`XMLHttpRequest`请求，从而克服了AJAX只能同源使用的限制\n+ 简单请求（simple request）和非简单请求（not-so-simple request）的判定\n>（1) 请求方法是以下三种方法之一：\n\t-   HEAD\n\t-   GET\n\t-   POST\n\t- \n\t（2）HTTP的头信息不超出以下几种字段：\n\t-   Accept\n\t-   Accept-Language\n\t-   Content-Language\n\t-   Last-Event-ID\n\t-   Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n\n+ 基本流程\n\t+ 简单请求：浏览器直接发出CORS请求（增加一个`Origin`字段）——源不在许可范围内——return一个正常的HTTP回应（不含`Access-Control-Allow-Origin`）——error\n\t+ 简单请求：源在许可范围内——服务器返回的响应，会多出几个头信息字段\n\t\t+ Access-Control-Allow-Origin（必须）\n\t\t+ Access-Control-Allow-Credentials（可选，是否允许发送cookie）\n\t\t+ Access-Control-Expose-Headers（可选：可以拿到指定的`getResponseHeader()`拿不到的字段）\n\t+ 非简单请求：在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）——\"预检\"请求的头信息包括两个特殊字段\n\t\t+ Access-Control-Request-Method（必须：列出浏览器的CORS请求会用到哪些HTTP方法）\n\t\t+ Access-Control-Request-Headers（指定浏览器CORS请求会额外发送的头信息字段）\n\t\t```http\n\t  \tOrigin: http://api.bob.com\n\t\tAccess-Control-Request-Method: PUT\n\t\tAccess-Control-Request-Headers: X-Custom-Header\n\t  ```\n\t  ——预检请求的回应\n\t  ——浏览器的正常请求和回应\n\n**CORS支持所有类型的HTTP请求**\n\n\n#### 3、nginx反向代理：\n+ 例如：www.baidu.com/index.html 需要调用 www.sina.com/server.php， 可以写一个接口 www.baidu.com/server.php， 由这个接口在后端去调用 www.sina.com/server.php 并拿到返回值，然后再返回给index.html\n#### 4、document.domain\n+ 跨域分为两种，一种xhr不能访问不同源的文档，另一种是不同window之间不能进行交互操作;  \n+ document.domain主要是解决第二种情况，且只能适用于主域相同而子域不同的情况；\n+ document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同；\n+ 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法；\n\n#### 5、window.name\n+ window中name属性特征：在一个窗口的生命周期内，窗口载入的所有页面都是共享一个 window.name\n+ 使用`iframe`来充当一个中间人的角色，用它获取到 `b.html `的通过`window.name`设置的数据——把`iframe`的`src`设置为与`a.html`同一个域——`a.html`就能访问到`iframe`里的`window.name`的数据\n\n#### 6、window.postMessage\n+ h5新引进的概念\n+ 可以使用它来向其他的window对象发送消息，无论这个window对象是不是同源\n\n\n\n\n","tags":["kilimanjaro"]},{"title":"关于网络请求的学习笔记","url":"/articles/10005/","content":"### xhr Learning\nkidish:  axios你用过没\nme：这是啥？...... 不好意思暴露智商了\nkidish：那你从原生开始写吧 ...\n\n关于这一部分知识，一直都只是看过好几次文档，但是没有动手写过，这一次刚好系统地过一遍。\n\n#### 1、Ajax\n+ asynchronous JavaScript an XML\n+ 原生Ajax大致写法及一些涉及到的知识，[一篇写得挺好的简书](https://www.jianshu.com/p/2be2e4f1fc8e)\n和另外一个挺好的[学习参考](https://segmentfault.com/a/1190000004100271)\n+ 基本写法\n\t1、 创建请求\n\t```js\n\tvar xhr = new XMLHttpRequest();\n\txhr.open('GET', 'send-ajax-data.php'); //POST\n\txhr.send(null); //POST要传参\n\t```\n\t关于XMLHttpRequest：\n\t!!! 大多浏览器都有XMLHttpRequest对象，但是IE5/IE6，需要判断是否支持，否则需要使用ActiveObject对象\n\t[XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)\n\t```js\n\tif(window.XMLHttpRequest) {\n\t\txhr = new XMLHttpRequest();\n\t}else{\n\t\txhr = new ActiveObject(\"Miscrosoft.XMLHTTP\")\n\t}\n\t```\n\t 2 、处理服务器响应\n\t```js\n\t xhr.onreadystatechage = function(){\n     if(xhr.readyState == 4){\n        if(xhr.status == 200){\n             console.log(xhr.responseText)\n        }else{\n            console.log(\"ERROR:\" + xhr.status)\n        }\n     }\n  }\n\t```\n\t**`onreadystatechage`[w3school](http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_onreadystatechange.asp)**\n\t每当 readyState 改变时，就会触发 onreadystatechange 事件\n\t`readyState`\n\t+ 0: 请求未初始化\n\t+ 1: 服务器连接已建立\n    + 2: 请求已接收\n    + 3: 请求处理中\n    + 4: 请求已完成，且响应已就绪\n  \n + GET 和 POST的区别\n\t>-   与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用；\n\t>-   GET存在缓存问题，使用GET方法一定要记得清除缓存，不然请求的数据不是最新的；\n\t>-   GET不安全，明文传输，POST更安全；\n\t>-   GET适用于小文件，POST没有数量限制；\n\t>-   GET使用send方法时不传参，POST必须传参；\n\n+ Ajax 请求头`content-type`，使用`setRequestHeader` 设置请求头\n+  `application/json`、`application/x-www-form-urlencoded` `text/plain`(默认)、`text/html`\n[简单参考](https://blog.csdn.net/u012794845/article/details/76255973)\n\t+ 当使用的是POST方法时：\n\t\t+ `content-type`为`application/x-www-form-urlencoded`(发送表单数据)的时候: 发送的参数会在`form data`中；\n\t\t+ 而为`application/json`、`text/plain`、`text/plain`会出现在`Request Payload`中\n\t+ 当使用的是GEt方法时：\n\t\t+ 参数出现在`Query String Parameters`中\n+ [ XMLHttpRequestEventTarget](https://developer.mozilla.org/en/DOM/XMLHttpRequestEventTarget)\n+ **http-server**\n\t之前说得光看文档不写，多半是没有了解到这种的存在\n\thttp-server ：简单的零配置命令行HTTP服务器, 基于 nodeJs\n\t安装：`npm install http-server -g`\n    使用：打开到工程目录运行`http-server`\n\t>-p 端口号 (默认 8080)\n-a IP 地址 (默认 0.0.0.0)\n-d 显示目录列表 (默认 'True')\n-i 显示 autoIndex (默认 'True')\n-e or --ext 如果没有提供默认的文件扩展名(默认 'html')\n-s or --silent 禁止日志信息输出\n--cors 启用 CORS via the Access-Control-Allow-Origin header\n-o 在开始服务后打开浏览器\n-c 为 cache-control max-age header 设置Cache time(秒) , e.g. -c10 for 10 seconds (defaults to '3600'). 禁用 caching, 则使用 -c-1.\n-U 或 --utc 使用UTC time 格式化log消息\n-P or --proxy Proxies all requests which can't be resolved locally to the given url. e.g.: -P http://someurl.com\n-S or --ssl 启用 https\n-C or --cert ssl cert 文件路径 (default: cert.pem)\n-K or --key Path to ssl key file (default: key.pem).\n-r or --robots Provide a /robots.txt (whose content defaults to 'User-agent: *\\nDisallow: /')\n-h or --help 打印以上列表并退出\n\n+ **http-server ./ -P XXXX**代理\n+ 例如，打开工程目录，运行\n\t>$ http-server ./ -P https://blog.csdn.net\n\tStarting up http-server, serving ./\n\tAvailable on:\n\t  http://192.168.1.105:8080\n\t  http://127.0.0.1:8080\n\tUnhandled requests will be served from: https://blog.csdn.net\n\tHit CTRL-C to stop the server\n\thttp-server stopped.\n    ```js\n    var  xhr = new  XMLHttpRequest\n    xhr.open('GET','/api/articles?type=more&category=home&shown_offset=1540351013034122&first_view=false')\n    xhr.send()\n    xhr.onreadystatechage = function(){\n\t  if(xhr.readyState == 4){\n\t    if(xhr.status == 200){\n\t\t    console.log(xhr.responseText)\n\t    }else{\n\t   console.log(\"ERROR:\" + xhr.status)\n\t  }\n     }\n   }\n    ```\n  于是通过代理就可以成功进行请求了，就可以开始了我的动手旅程，应该是我最新的收获了，终于可以不再只看不写了~\n + POST的尝试：\n```js\n//https://www.zhihu.com/api/v4/articles/45395824/voters\nvar  xhr = new  XMLHttpRequest\nxhr.open('POST','/lastread/touch')\nxhr.setRequestHeader(\"Content-type\", \"application/json\")\nvar  obj = {voiting:1}\nobj = JSON.stringify(obj)\nxhr.send(obj)\nxhr.onreadystatechange = function(){\n  if(xhr.readyState == 4){\n\tif(xhr.status == 200){\n\t   console.log(xhr.response)\n    }else{\n       console.log(\"ERROR:\" + xhr.status)\n    }\n  }\n}\n```\n+ 后面的就是: 不同的设置条件的各种请求的尝试，以及用Jquery的尝试\n+ 感觉这一块还有好多要学习的，要把之前看的东西串起来\n+ 用kidish的话来说就是：我要给你补得还有好多...\n\n#### 2、Axios\n[Axios文档](https://www.kancloud.cn/yunye/axios/234845)\n\n+ 定义：Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中\n+ 安装：`$ npm install axios`\n+ 引入： `import  axios  from  'axios'`\n    cdn： `https://unpkg.com/axios/dist/axios.min.js`\n\n**使用**\n1）get请求\n```js\naxios.get('/api/articles?type=more&category=home&shown_offset=1540351013034122&first_view=false')\n.then(function(res){\n\tconsole.log(res)\n})\n.catch(function(error){\n\tconsole.log(error)\n})\n```\n2）post请求\n```js\naxios.post('/api/v4/articles/45395824/voters',{\n\tparams:{\n\t  voting:1\n\t}\n})\n.then(function(res){\n\tconsole.log(res)\n})\n.catch(function(error){\n\tconsole.log(error)\n})\n```\n\n3）执行多个并发请求\n```js\nfunction  getHomeArticle(){\n\treturn  axios.get('/api/articles?type=more&category=home&shown_offset=1540351013034122&first_view=false')\n}\nfunction  getCareerArticle(){\n\treturn  axios.get('/api/articles?type=more&category=career&shown_offset=1540450144315916')\n}\naxios.all([getHomeArticle(),getCareerArticle()])\n.then(axios.spread(function(home,career){\n\tconsole.log(home)\n\tconsole.log(career)\n}))\n```\n**`axios.all(iterable)`** **`axios.spread(callback)`**\n\n4）**`axios(url[, config])`**\n```js\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\n——请求方法的别名\n>  axios.request(config)\n\taxios.get(url[, config])\n\taxios.delete(url[, config])\n    axios.head(url[, config])\n    axios.post(url[, data[, config]])\n    axios.put(url[, data[, config]])\n    axios.patch(url[, data[, config]])\n\n在使用别名方法时， `url`、`method`、`data` 这些属性都不必在配置中指定\n若想指定其他参数，可以使用`实例方法`如：`axios#post(url[, data[, config]])`\n\n5）响应结构\n```js\n{\n  data: {},          // `data` 由服务器提供的响应\n  status: 200,       // `status` 来自服务器响应的 HTTP 状态码\n  statusText: 'OK',  // `statusText` 来自服务器响应的 HTTP 状态信息\n  headers: {},       // `headers` 服务器响应的头\n  config: {}         // `config` 是为请求提供的配置信息\n}\n```\n\n6）配置的默认值/defaults\n```js\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n 配置的优先顺序：库的默认值 < 实例的 `defaults` 属性 < 请求的 `config` 参数\n\n7）错误处理\n```js\naxios.get('/user/12345')\n  .catch(function (error) {\n    if (error.response) {\n      // 请求已发出，但服务器响应的状态码不在 2xx 范围内\n      console.log(error.response)\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.log('Error', error.message);\n    }\n    console.log(error.config);\n  });\n```\n+ 可以使用 `validateStatus` 配置选项定义一个自定义 HTTP 状态码的错误范围\n```js\naxios.get('/user/12345', {\n  validateStatus: function (status) {\n    return status < 500; // 状态码在大于或等于500时才会 reject\n  }\n})\n```\n+ kidish的封装：\n```js\n.catch(e  => {\n\te.response  ?  cb(e.response) :  cb({status:  500,data:{result:  'errInter'}})\n})\n```\n\n#### 3、jQuery中的Ajax\n` jQuery.ajax( url [, settings ] )`\n[中文文档](http://www.css88.com/jqapi-1.9/jQuery.ajax/#jQuery-ajax-settings)   `settings`参数及设置\n```js\n$.ajax({url:  \"api/articles?type=more&category=home&shown_offset=1540351013034122&first_view=false\",\n\tcontentType:  \"application/json\"\n}).done(function(res){\n\tconsole.log(res);\n}).fail(function(){\n\tconsole.log(\"Error: \" + err.status);\n})\n```\n+   [jQuery.get( url [, data ] [, success ] [, dataType ] )](http://www.css88.com/jqapi-1.9/jQuery.get/#jQuery-get-url-data-success-dataType)\n\n+ `[, success ] ` 为当请求成功时运行的函数\n```js\nvar  data = {voting:1}\ndata = JSON.stringify(data)\n$.post('/api/v4/articles/45395824/voters',{data},\n\tfunction(data,status){\n\t\tconsole.log(\"Data: \" + data + \"\\nStatus: \" + status);\n\t},\"json\"\n);\n```\n + [jQuery.get( url [, data ] [, success ] [, dataType ] )](http://www.css88.com/jqapi-1.9/jQuery.get/#jQuery-get-url-data-success-dataType)\n```js\n$.get('api/articles?type=more&category=home&shown_offset=1540351013034122&first_view=false',\n\tfunction(data,status){\n\t\tconsole.log(data)\n\t\tconsole.log(status) //success\n\t}\n);\n```\n更多使用，总感觉用到了才知道。。。。。。\n\n\n\n\t\t\n\n","tags":["kilimanjaro"]},{"title":"几个个人经常使用的linux命令","url":"/articles/10003/","content":"\n## scp\n上传文件/文件夹到服务器\n```bash\n# 把当前目录下的 dist 文件夹上传到 ssh 开放端口为 2222 的服务器下的 opt 目录\nscp -P 2222 -r dist vagrant@*.*.*.*:/opt/\n# 把服务器上的 opt 文件下的 test.js 文件复制到本地 tmp 文件夹下\nscp vagrant@*.*.*.*:/opt/test.js /tmp\n```\n\n## ssh\n连接远程服务器/远程执行命令\n```bash\n# 连接到开放 2222 端口的指定的服务器\nssh -P 2222 vagrant@*.*.*.* \n# 远程执行命令 多个命令用 “;”隔开\nssh vagrant@*.*.*.*  \" ls / ; pwd \"\n```\n\n","tags":["linux"]},{"title":"思想养成篇-能少计算就少计算","url":"/articles/10002/","content":"### 思想养成篇（一）  能少计算就少计算\n2018/10/22\n\n**kidish：js不是一个擅长计算密集型的语言 所以能减少计算就减少计算**\n我：没反应过来，单纯记下了这句话\nthen：\n一个计算文件从创建开始距今的时间的函数（n years /months/days/mimutes/seconds ago）\n##### 我的代码:\n```js\ntimeToShow(createtime) {\nvar  time  = [];\nvar  showTime  =  0;\nvar  timestamp  =  Date.parse(new  Date());\nvar  timeSub  =  timestamp  -  createtime  *  1000\nvar  years  =  parseInt(timeSub  / (1000  *  60  *  60  *  24  *  30  *  365))\nvar  months  =  parseInt(timeSub  / (1000  *  60  *  60  *  24  *  30))\nvar  days  =  parseInt(timeSub  / (1000  *  60  *  60  *  24))\nvar  hours  =  parseInt(timeSub  / (1000  *  60  *  60))\nvar  minutes  =  parseInt(timeSub  / (1000  *  60))\nvar  seconds  =  parseInt(timeSub  /  1000)\ntime.push(years, months, days, hours, minutes, seconds)\nfor(var  i  =  0; i  <  6; i++){\n  if(time[i] >  0){\n    showTime  =  time[i];\n    switch(i){\n\t  case  0 : showTime  =  showTime  +  'years ago'; break;\n\t  case  1 : showTime  =  showTime  +  'months ago'; break;\n\t  case  2 : showTime  =  showTime  +  'days ago'; break;\n\t  case  3 : showTime  =  showTime  +  'hours ago'; break;\n\t  case  4 : showTime  =  showTime  +  'mimutes ago'; break;\n\t  case  5 : showTime  =  showTime  +  'seconds ago'; break;\n\t}\n  break;\n  }\n}\nreturn  showTime;\n},\n```\n\n##### kidish的:\n```js\nfileter(sec){\n  let  mincount  =  60\n  let  hcount  =  3600\n  let  dcount  =  86400\n  let  mcount  =  2592000\n  let  ycount  =  31104000\n  let  cur  = (new  Date()).getTime() /  1000\n  let  cha  =  parseInt(cur  -  sec)\n  let  cache  = {}\n  if (Boolean(cache.chay  =  cha  /  ycount) &&  cache.chay  >=  1) {\n\treturn {\n\t  path:  'time.year',\n\t  args:{\n\t    num:  parseInt(cache.chay)\n\t  }\n    }\n  } else  if (Boolean(cache.cham  =  cha  /  mcount) &&  cache.cham  >=  1) {\n\treturn {\n\t  path:  'time.month',\n\t  args: {\n\t\tnum:  parseInt(cache.cham)\n\t  }\n\t}\n  } else  if (Boolean(cache.chad  =  cha  /  dcount) &&  cache.chad  >=  1) {\n\treturn {\n\t  path:  'time.day',\n\t  args: {\n\t    num:  parseInt(cache.chad)\n\t  }\n    }\n  } else  if (Boolean(cache.chah  =  cha  /  hcount) &&  cache.chah  >=  1) {\n\treturn {\n\t  path:  'time.hour',\n\t  args: {\n\t\tnum:  parseInt(cache.chah)\n\t  }\n\t}\n  } else  if (Boolean(cache.chami  =  cha  /  mincount) &&  cache.chami  >=  1) {\n\treturn {\n\t  path:  'time.min',\n\t  args: {\n\t\tnum:  parseInt(cache.chami)\n\t  }\n\t}\n  } else {\n\treturn {\n\t  path:  'time.sec',\n\t  args: {\n\t\tnum:  cha\n\t  }\n\t}\n  }\n}\n```\n\n看见这段的时候就恍然大悟，真的是反应力太差\n+ ` (1000  *  60  *  60  *  24  *  30  *  365)`类似于这种可以自行计算的，就不应该再让程序来替我们计算~\n+ 鉴于这个函数要显示的结果是有year就不显示month，有month就不显示day... 所以我先前写的`每个数据都计算出来，再判断显示哪个`的思路 VS `从year开始计算，一旦>1就不再往下计算`，显然后者可以达到缩减计算量的目的。\n\n**So——思想养成：\n\t能少计算就少计算   \n\t能少计算就少计算  \n\t能少计算就少计算**\n\n[一个有点相关又不大相关的参考](https://www.cnblogs.com/cnblogs-jcy/p/5654351.html)\n[编译型语言VS解释型语言](https://blog.csdn.net/weixin_38055381/article/details/82420661)\n","tags":["kilimanjaro"]},{"title":"vue学习笔记","url":"/articles/10001/","content":"### vueNotes (2018/10/2~2018/10/19)  \n  \n#### 1.Vue.js文档学习  \n+ 生命周期函数：beforeCreated/ created/ boforeMount/ mounted/ beforeUpdate/ updated/ beforeDertroy/ destroyed/<br>  \n! 不要在选项属性上或回调函数上使用箭头函数，因为箭头函数是和父级上下文绑定在一起的  \n+ V-html 可以输出真正的HTML，而双花括号会将数据解释为普通文本，所以需要注意：站点上动态渲染的HTML可能会比较危险，容易导致XSS攻击  \n+ v-on简写为`@XXX=\"YYY\"` v-bind简写为`:XXX=\"YYY\"`  \n+ Vue Router ($router 路由对象)  \n* `$router.path`: 当前路由的路径  \n* `$router.params`: key/value(object)  \n* `$router.query`: URL查询参数、key/value(object)  \n  \n  \n#### 2.环境安装、项目搭建  \n+ 注意node.js环境变量的配置就好  \n+ 初始项目搭建： [参考步骤](https://www.jianshu.com/p/1626b8643676)，了解框架的文件结构  \n#### 3.代码练习  \nQ：路由配置问题：<router-view/>理解不当，页面重复出现  \nS：只有在需要的地方写，不能每个组件都写上这个  \n  \n---  \nQ:  出现页面的滚动条问题  \nS：理解和使用box-sizing属性，通过设置 box-sizing: border-box；改变盒模型来调整布局解决滚动条问题。  \n  \n---  \nQ: menu选中状态设置问题，当刷新时，路由因为设置跳转可以保持原路由，但是menu菜单的选中项会变成默认的设置项（default-active）  \nS:\n```html\n<div class=\"menu-content\">  \n<div>  \n<el-menu :default-active=\"$route.path\" class=\"el-menu-vertical-demo\">  \n<router-link to=\"/myCloud\">  \n  <el-menu-item :index=\"`/myCloud`\">  \n    <i class=\"el-icon-document\"><span slot=\"title\" class=\"menu-title\">My Cloud</span></i>  \n  </el-menu-item>  \n</router-link>  \n<router-link to=\"/recycle\">  \n  <el-menu-item :index=\"`/recycle`\">  \n    <i class=\"el-icon-delete\"><span slot=\"title\" class=\"menu-title\">Recycle Bin</span></i>  \n  </el-menu-item>  \n</router-link>  \n</el-menu>  \n</div>  \n</div>  \n```\n//将default-active设为当前的路径，而index设置为相应的路径,注意你之前使用的是go('path')的方法设置跳转，建议不用，用<router-link to='path'>来替代  \n  \n---  \nQ: 列表的hover、selected、之间状态转换效果的实现  \nS:\n```css\n.list-item :hover{  \nbackground: #f6f6f6;  \n}  \n  \n.list-item-row.selected{  \nbackground: #f4f8ff;  \n}  \n```\n通过不同的时候的样式来进行切换，hover才显示的可以设置display：none/block来切换，而selected是通过vue绑定类名的方式来设置不同样式  \n```html\n<div class=\"list-item-row\" :class=\"{ selected: checked, clickedMore:clickedMore }\">  \n```\n  \n[class与style绑定](https://cn.vuejs.org/v2/guide/class-and-style.html)  \n  \n---  \nQ: 列表如果使用v-for实现的话，会共用一个判断状态，致使列表所有Item的状态共同变化  \nS: 养成独立思想：把每一个ListItem写成一个组件，这样每一个item就能拥有独立的状态控制  \n  \n---  \nQ: 父组件与子组件之间的传值  \nS: 父组件向子组件传值：  \n子组件在props中接受，而父组件在调用子组件的时候通过 '：XXX=YYY'的形式传递，如：  \n子组件中：  \n```js\nprops:['id','filename','filesize','updatetime','checkModel'],\n```  \n父组件中：  \n```html\n<fileCreateBox :fileType=\"this.fileType1\" :dialogVisible=\"this.dialogVisible1\" @closeBox=\"dialogVisible1 = false\"></fileCreateBox>  \n```\n子组件向父组件传值：  \n`this.$emit()`函数：把事件沿着作用域链向上派送，作用是触发自定义事件  \n`this.$emit(event,要传给父组件的值）`例如：  \n子组件中：  \n```js\nthis.$emit('deleteCheck',this.id)  \n```\n父组件中：\n```html  \n<ListItem @deleteCheck=\"deleteCheckItem\"></ListItem>  \n```\n然后再methods中定义相关的方法：  \n```js\ndeleteCheckItem(id){  \nthis.checkModel.splice(this.checkModel.indexOf(id),1);  \n},  \n```\n[this.$emit()](https://blog.csdn.net/sllailcp/article/details/78595077)  \n  \n---  \nQ:全选和单选的实现  \nS:思路：主要利用v-model，用一个数组记录被选中的id,然后在子组件ListItem中判断此item的id是否在数组中，从而改变其选中/不选中的状态，主要代码如下：  \n  \n父组件：v-model=\"checkedAll\"  \n```js\ncomputed: {  \ncheckedAll: {  \nget(){return (this.checkModel.length == this.files.length)},  \n  set(){  \n    if(!this.checkedAll){  \n      this.checkModel = []  \n      this.files.forEach((value,index)=>{  \n      this.checkModel.push(value.id);  \n    });  \n   }else{  \n     this.checkModel = []  \n   }  \n  }  \n },  \n}  \n```\n  \n子组件：v-model=\"checked\"  \n```js\ncomputed:{  \nchecked:{  \n  get(){return (this.checkModel.indexOf(this.id) > -1)},  \n  set(){  \n    this.checked ? this.$emit('deleteCheck',this.id) : this.$emit('addCheck',this.id)  \n  }  \n },  \n},  \n```\n  \n!!!不能直接改变props的值，也不能直接改变computed属性的值，所以当需要改变其值时，要利用computed中的setter函数实现，通过改变它的依赖来改变它自身的值  \n  \n！！！**不能滥用`watch`**,而是需要使用`computed`属性替代</br>  \n[计算属性](https://cn.vuejs.org/v2/guide/computed.html)  \nwatch computed 两者均可以观察页面的数据变化，但是computed只在相关的数据发生变化的时候才会改变它的值，存在缓存，而watch每一次都会执行函数，所以要养成一个思想：**computed属性要多用，watch不要滥用，目前还没看见该使用它的场合，有待研究**  \n  \n---  \nQ:点击列表上的按钮的时候，列表本身的click事件也会被触发  \nS:事件冒泡/阻止冒泡/事件捕获/阻止捕获相关知识  \n+ event.stopPropagation() 除IE外的浏览器使用  \n+ event.cancelBubble = true IE下才起作用，所以上述两个结合使用  \n+ 直接在click事件添加.stop：@click.stop = \"changeState\"  \n+ event.preventDefault(),不阻止事件冒泡，阻止默认行为  \n+ return flase的方法，阻止冒泡和默认  \n  \n---  \nQ:点击整个页面除指定区域外的某个地方，改变一个状态地方法  \nS:  \n```js\nmounted:function(){  \n  var _this = this  \n  document.addEventListener('click', function (e) {  \n    let flag = e.target.contains(document.getElementsByClassName('file-action')[0])  \n    if(!flag) {  \n      return _this.clickedMore = false  \n    }  \n  })  \n},  \n```\n  \n利用addEventListener添加全局点击事件，把指定区域用(id)选中，取反，注意  \nvar _this = this 的this的绑定(理由暂时没研究出来，但是不这么写不会起作用)  \n**this的指向问题**\n`this` 指向并不是在函数定义的时候确定的，而是在调用的时候确定的\n**函数的调用方式决定了  `this`  指向**\n+ 直接调用(window)、注意 `bind()` 的影响、`call `和 `apply`的影响（this指向传入函数的第一个参数）\n+ 方法调用（指向调用该方法的对象）\n+ 调用事件处理函数的时候，`this` 指向会绑定到触发事件的 DOM 元素上（可用`var _this = this`或`bind`或`箭头函数`来解决这一问题）\n+ new调用（新创建的函数）\n+ **箭头函数中的 this**： 箭头函数没有自己的 `this` 绑定。箭头函数中使用的 `this`，其实是直接包含它的那个函数或函数表达式中的 `this`**箭头函数是根据外层（函数或者全局）作用域来决定this**\n箭头函数不会绑定`this`， 或则说箭头函数不会改变`this`本来的绑定，所以call()、apply()、bind()这些方法不会改变this的指向\n\n**[参考学习](https://segmentfault.com/a/1190000008400124)**\n \n---  \n距离建立时间距今的显示：  \n```js\ntimeToShow(createtime) {  \nvar time = [];  \nvar showTime = 0;  \nvar timestamp = Date.parse(new Date());  \nvar timeSub = timestamp - createtime*1000  \nvar  years  =  parseInt(timeSub  / (1000  *  60  *  60  *  24  *  30  *  365))\nvar  months  =  parseInt(timeSub  / (1000  *  60  *  60  *  24  *  30))\nvar  days  =  parseInt(timeSub  / (1000  *  60  *  60  *  24))\nvar  hours  =  parseInt(timeSub  / (1000  *  60  *  60))\nvar  minutes  =  parseInt(timeSub  / (1000  *  60))\nvar  seconds  =  parseInt(timeSub  /  1000)  \ntime.push(years, months, days, hours, minutes, seconds)  \n// console.log(time)  \nfor(var i = 0; i < 6; i++){  \n  if(time[i] > 0){  \n    showTime = time[i];  \n    switch(i){  \n      case 0 : showTime = showTime + 'years ago'; break;  \n      case 1 : showTime = showTime + 'months ago'; break;  \n      case 2 : showTime = showTime + 'days ago'; break;  \n      case 3 : showTime = showTime + 'hours ago'; break;  \n      case 4 : showTime = showTime + 'mimutes ago'; break;  \n      case 5 : showTime = showTime + 'seconds ago'; break;  \n    }  \n  break;  \n  }  \n}  \nreturn showTime;  \n}  \n有待优化\n```\n！时间戳与日期的互相转换  \n  \n---  \n  \n#### 4、other  \n+ input去掉点击时候的默认蓝框框的方法：  \nstyle = \"outline:none\"  \n+ [element.ui组件库](http://element-cn.eleme.io/#/)  \n+ label for属性  \n\n","tags":["kilimanjaro"]},{"title":"nodejs解析excel之node-xlsx","url":"/articles/10004/","content":"### 工作中遇到一个简单的需求：\nPM给出一个excel,里边包含两个 sheet,sheet1为某app拥有的所有的权限，sheet2为google定义涉及的敏感权限列表，而我则需要生成一个json数据并且标识出某些敏感权限。\n\n### node-xlsx\n尝试了几个其他的库后发现这个还是比较好用的\n这个库特别简单，只有两个方法\n`parse` 转换 excel 为 数组对象\n`build` 输出 excel 文件\n\n```js\nconst xlsx = require('node-xlsx')\nconst fs = require('fs')\n\nconst sheet = xlsx.parse('./test.xlsx')\n\nconst getData = (i) => {\n\n\treturn sheet[i].data.map(item => {\n\t\n\t\tobj = {}\n\t\tobj[item[0]] = {\n\t\t\tdesc: item[1]\n\t\t}\n\t\treturn obj\n\t\t\n\t})\n\t\n}\n\nsheet1 = getData(0) // common\nsheet2 = getData(1) // danger\n\nsheet2.map((item) => {\n\n\tvar len = sheet1.length;\n\n\tfor (var i = 0; i < len; i++) {\n\n\t\tif(Object.keys(sheet1[i])[0] == Object.keys(item)[0]){\n\t\t\n\t\t\titem[Object.keys(item)[0]].danger = true\n\t\t\treturn item\n\t\t\t\n\t\t}\n\t}\n\n\treturn item\n\n})\n\nconst result = {}\n\nfor (var i =0 ;i < sheet2.length;i++){\n\n\tlet key = Object.keys(sheet2[i])[0]\n\tresult[key] = sheet2[i][key]\n\n}\n\nfs.writeFileSync('./result.json',JSON.stringify(result))\n```\n\n通过以上代码便简单完成了对xlsx的解析。\n","tags":["nodejs"]},{"title":"如何判断变量是否为数组？","url":"/articles/10000/","content":"## 如何判断某元素是否是数组\n### typeof\n`typeof` 操作符对于除了 `null` 的基本数据类型(包括 `symble` )都是可以信任的，但是对于数组而言，`typeof` 操作符此时并不能返回正确的结果。\n\n### instanceof\n我们检测数组最常用的方法是 `instanceof`\n\n```js\n var list = []\n list instanceof Array // true\n list instanceof Object // 同时list也是Object的实例\n```\n`但是以上方法是建立在全局只有一个window的情况下，如果存在iframe 那么判断两个window下的数组是否为另一个window.Array的实例就会出现问题。`\n\n### toString\n`toString` 是个比较安全的方法\n通常我们可以先取到 `Object` 原型中的 `toString` 方法\n```js\n var _toString = Object.prototype.toString\t\n _toString.call(variable)  // [object Undefined]\n```\n我们可以拿到方括号后边的类型即为当前变量的实际类型\n","tags":["javascript"]}]